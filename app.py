import os
import streamlit as st
import pandas as pd
import joblib
import tensorflow as tf
import numpy as np
import plotly.express as px
from PIL import Image
from lifelines import CoxPHFitter
from tensorflow.keras.models import load_model as tf_load_model

# --- Patch scikit-learn pour √©viter l'erreur 'sklearn_tags' ---
try:
    from sklearn.base import BaseEstimator
    if not hasattr(BaseEstimator, "sklearn_tags"):
        @property
        def sklearn_tags(self):
            return {}
        BaseEstimator.sklearn_tags = sklearn_tags
except Exception as e:
    pass

# ----------------------------------------------------------
# Configuration de l'application
# ----------------------------------------------------------
st.set_page_config(
    page_title="MOYO",
    page_icon="‚öïÔ∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Chemins vers les ressources
DATA_PATH = "data/data.xlsx"
LOGO_PATH = "assets/header.jpg"
TEAM_IMG_PATH = "assets/img0.jpeg"

# Configuration des mod√®les
MODELS = {
    "Cox PH": "models/coxph.joblib",
    "RSF": "models/rsf.joblib",
    "DeepSurv": "models/deepsurv.keras",
    "GBST": "models/gbst.joblib"
}

# Configuration des variables
# Pour AGE, on souhaite conserver la valeur num√©rique, pour les autres, conversion Oui/Non
FEATURE_CONFIG = {
    "AGE": "√Çge",
    "Cardiopathie": "Cardiopathie",
    "Ulceregastrique": "Ulc√®re gastrique",
    "Douleurepigastrique": "Douleur √©pigastrique",
    "Ulcero-bourgeonnant": "L√©sion ulc√©ro-bourgeonnante",
    "Denitrution": "D√©nutrition",
    "Tabac": "Tabagisme actif",
    "Mucineux": "Type mucineux",
    "Infiltrant": "Type infiltrant",
    "Stenosant": "Type st√©nosant",
    "Metastases": "M√©tastases",
    "Adenopathie": "Ad√©nopathie",
}


# D√©finition des chemins d'images
TEAM_MEMBERS = [
    {
        "name": "Pr. Aba Diop",
        "role": "Ma√Ætre de Conf√©rences",
        "email": "aba.diop@example.com",
        "linkedin": "https://linkedin.com/in/abadiop",
        "photo": "assets/abadiop.jpeg"  # Remplacez par le vrai chemin
    },
    {
        "name": "PhD. Idrissa Sy",
        "role": "Enseignant Chercheur",
        "email": "idrissa.sy@example.com",
        "linkedin": "https://linkedin.com/in/idrissasy",
        "photo": "assets/idrissasy.jpeg"  # Remplacez par le vrai chemin
    },
    {
        "name": "M. Ahmed Sefdine",
        "role": "√âtudiant",
        "email": "ahmed.sefdine@example.com",
        "linkedin": "https://linkedin.com/in/sefdineahmed",
        "photo": "assets/sefdine.jpeg"  # Remplacez par le vrai chemin
    }
]

# ----------------------------------------------------------
# Fonctions Utilitaires
# ----------------------------------------------------------
@st.cache_data(show_spinner=False)
def load_data():
    """Charge les donn√©es depuis le fichier Excel."""
    if os.path.exists(DATA_PATH):
        return pd.read_excel(DATA_PATH)
    else:
        st.error(f"‚ùå Fichier introuvable : {DATA_PATH}")
        return pd.DataFrame()

@st.cache_resource(show_spinner=False)
def load_model(model_path):
    """
    Charge un mod√®le pr√©-entra√Æn√©.
    Pour les mod√®les Keras (.keras ou .h5) on utilise tf.keras.models.load_model.
    Pour les autres, joblib.load.
    """
    if not os.path.exists(model_path):
        st.error(f"‚ùå Mod√®le introuvable : {model_path}")
        return None

    try:
        _, ext = os.path.splitext(model_path)
        if ext in ['.keras', '.h5']:
            # Fonction de perte custom pour DeepSurv (si n√©cessaire)
            def cox_loss(y_true, y_pred):
                event = tf.cast(y_true[:, 0], dtype=tf.float32)
                risk = y_pred[:, 0]
                log_risk = tf.math.log(tf.cumsum(tf.exp(risk), reverse=True))
                loss = -tf.reduce_mean((risk - log_risk) * event)
                return loss
            return tf_load_model(model_path, custom_objects={"cox_loss": cox_loss})
        else:
            return joblib.load(model_path)
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement du mod√®le : {e}")
        return None

def encode_features(inputs):
    """
    Encode les variables.
    Pour 'AGE', on conserve la valeur num√©rique.
    Pour les autres, "OUI" devient 1 et toute autre valeur 0.
    """
    encoded = {}
    for k, v in inputs.items():
        if k == "AGE":
            encoded[k] = v
        else:
            encoded[k] = 1 if v.upper() == "OUI" else 0
    return pd.DataFrame([encoded])

def predict_survival(model, data, model_name):
    """
    Effectue la pr√©diction du temps de survie selon le type de mod√®le.
    """
    if hasattr(model, "predict_median"):
        pred = model.predict_median(data)
        if hasattr(pred, '__iter__'):
            return pred.iloc[0] if isinstance(pred, pd.Series) else pred[0]
        return pred
    elif hasattr(model, "predict"):
        prediction = model.predict(data)
        if isinstance(prediction, np.ndarray):
            if prediction.ndim == 2:
                return prediction[0][0]
            return prediction[0]
        return prediction
    else:
        raise ValueError(f"Le mod√®le {model_name} ne supporte pas la pr√©diction de survie.")

def clean_prediction(prediction, model_name):
    """
    Nettoie la pr√©diction pour √©viter les valeurs n√©gatives.
    """
    try:
        pred_val = float(prediction)
    except Exception:
        pred_val = 0
    if model_name in ["Cox PH", "RSF", "GBST"]:
        return max(pred_val, 0)
    elif model_name == "DeepSurv":
        return max(pred_val, 1)
    else:
        return pred_val

def save_new_patient(new_patient_data):
    """
    Enregistre les informations d'un nouveau patient dans le fichier Excel.
    """
    df = load_data()
    # Cr√©er un DataFrame √† partir des donn√©es du nouveau patient
    new_df = pd.DataFrame([new_patient_data])
    # Utiliser pd.concat pour combiner les DataFrames
    df = pd.concat([df, new_df], ignore_index=True)
    # Sauvegarder le DataFrame mis √† jour
    try:
        df.to_excel(DATA_PATH, index=False)
        st.success("Les informations du nouveau patient ont √©t√© enregistr√©es.")
        # Effacer le cache pour que load_data recharge le fichier mis √† jour
        load_data.clear()
    except Exception as e:
        st.error(f"Erreur lors de l'enregistrement des donn√©es : {e}")

# ----------------------------------------------------------
# D√©finition des Pages
# ----------------------------------------------------------
def accueil():
    col1, col2 = st.columns([1, 3])
    with col1:
        if os.path.exists(LOGO_PATH):
            st.image(LOGO_PATH, width=200)
    with col2:
        st.title("‚öïÔ∏è Plateforme d'Aide √† la D√©cision")
        st.markdown("**Estimation du temps de survie post-traitement du cancer gastrique**")
    st.markdown("---")
    st.write(
        """
        ### Fonctionnalit√©s principales :
        - üìä Exploration interactive des donn√©es cliniques
        - üìà Analyse statistique descriptive
        - ü§ñ Pr√©diction multi-mod√®les de survie
        - üì§ Export des r√©sultats cliniques
        """
    )

def analyse_descriptive():
    st.title("üìä Analyse Exploratoire")
    df = load_data()
    if df.empty:
        return

    with st.expander("üîç Aper√ßu des donn√©es brutes", expanded=True):
        st.dataframe(df.head(5))
        st.write(f"Dimensions des donn√©es : {df.shape[0]} patients, {df.shape[1]} variables")
    
    st.markdown("---")
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìà Distribution des variables")
        selected_var = st.selectbox("Choisir une variable", df.columns)
        fig = px.histogram(df, x=selected_var, color_discrete_sequence=['#1f77b4'])
        st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        st.subheader("üå° Matrice de corr√©lation")
        numeric_df = df.select_dtypes(include=["number"])
        corr_matrix = numeric_df.corr()
        fig = px.imshow(corr_matrix, color_continuous_scale='RdBu_r', labels={"color": "Corr√©lation"})
        st.plotly_chart(fig, use_container_width=True)

def modelisation():
    st.title("ü§ñ Pr√©diction de Survie")
    
    # Saisie des informations du patient
    with st.expander("üìã Param√®tres du patient", expanded=True):
        inputs = {}
        cols = st.columns(3)
        for i, (feature, label) in enumerate(FEATURE_CONFIG.items()):
            with cols[i % 3]:
                if feature == "AGE":
                    inputs[feature] = st.number_input(label, min_value=18, max_value=120, value=50, key=feature)
                else:
                    inputs[feature] = st.selectbox(label, options=["Non", "Oui"], key=feature)
    
    input_df = encode_features(inputs)
    st.markdown("---")
    
    missing_columns = [col for col in FEATURE_CONFIG.keys() if col not in input_df.columns]
    if missing_columns:
        st.error(f"‚ùå Colonnes manquantes : {', '.join(missing_columns)}")
        return
    
    # Choix du mod√®le pour la pr√©diction
    model_name = st.selectbox("Choisir un mod√®le", list(MODELS.keys()))
    model = load_model(MODELS[model_name])
    
    if st.button("Pr√©dire le temps de survie"):
        if model:
            try:
                if model_name == "Cox PH" and hasattr(model, "params_"):
                    cols_to_use = list(model.params_.index) if hasattr(model.params_.index, '__iter__') else input_df.columns
                    input_df = input_df[cols_to_use]
                pred = predict_survival(model, input_df, model_name)
                cleaned_pred = clean_prediction(pred, model_name)
                if np.isnan(cleaned_pred):
                    raise ValueError("La pr√©diction renvoy√©e est NaN.")
                st.metric(label="Survie m√©diane estim√©e", value=f"{cleaned_pred:.1f} mois")
                
                months = min(int(cleaned_pred), 120)
                fig = px.line(
                    x=list(range(months)),
                    y=[100 - (i / months) * 100 for i in range(months)],
                    labels={"x": "Mois", "y": "Probabilit√© de survie (%)"},
                    color_discrete_sequence=['#2ca02c']
                )
                st.plotly_chart(fig, use_container_width=True)
            except Exception as e:
                st.error(f"‚ùå Erreur de pr√©diction pour {model_name} : {e}")

    st.markdown("---")
    # Bouton pour enregistrer les informations du patient dans la base de donn√©es
    if st.button("Enregistrer le patient"):
        save_new_patient(input_df.iloc[0].to_dict())

def a_propos():
    # Causes et transmission
    st.title("üìö Causes et Transmission au S√©n√©gal")
    st.markdown(
        """
        **Causes :**
        - L'infection par *Helicobacter pylori* constitue le principal facteur de risque du cancer gastrique.
        - Au S√©n√©gal, l'infection se contracte g√©n√©ralement d√®s l‚Äôenfance et peut persister si elle n'est pas trait√©e, entra√Ænant une inflammation chronique.

        **Transmission :**
        - La bact√©rie se transmet par voie orale (salive et liquides corporels), souvent via une transmission intra-familiale.
        - Des conditions comme un assainissement insuffisant et la promiscuit√©, fr√©quents dans certaines r√©gions s√©n√©galaises, favorisent sa propagation.
        """
    )
    st.image(TEAM_IMG_PATH, use_container_width=True)
    
    # Sympt√¥mes et √©volution de la maladie
    st.title("Sympt√¥mes et √âvolution")
    st.markdown(
        """
        **Sympt√¥mes :**
        - Douleurs abdominales, naus√©es, vomissements et perte de poids.
        - Dans certains cas, des saignements digestifs peuvent survenir.

        **√âvolution :**
        - La gastrite chronique li√©e √† *H. pylori* reste souvent asymptomatique.
        - Environ 10 % des personnes infect√©es d√©velopperont des ulc√®res et, dans 1 % des cas, une √©volution vers un cancer gastrique.
        """
    )

    # Diagnostic et traitements
    st.title("Diagnostic et Traitements")
    st.markdown(
        """
        **Diagnostic :**
        - Des tests invasifs (biopsies pour examen histologique, culture bact√©rienne et tests mol√©culaires) et non invasifs (test respiratoire, s√©rologie, d√©tection d'antig√®nes dans les selles) sont utilis√©s.
        - Au S√©n√©gal, l'acc√®s √† ces technologies peut √™tre variable, compliquant parfois le diagnostic pr√©coce.

        **Traitements :**
        - La trith√©rapie (IPP + deux antibiotiques) sur 7 jours permet d'√©radiquer la bact√©rie dans 70 % des cas.
        - En cas d‚Äô√©chec, un traitement de deuxi√®me ligne ou une quadrith√©rapie (Pylera) est envisag√© pour atteindre jusqu'√† 95 % d‚Äôefficacit√©.
        - La r√©sistance aux antibiotiques reste un d√©fi majeur.
        """
    )

    # Pr√©vention et impact
    st.title("Pr√©vention et Impact au S√©n√©gal")
    st.markdown(
        """
        **Pr√©vention :**
        - Am√©liorer les conditions d'hygi√®ne (acc√®s √† une eau potable de qualit√© et assainissement des milieux de vie).
        - Promouvoir l'√©ducation sanitaire pour limiter la transmission.
        - Encourager un mode de vie sain (arr√™t du tabac, consommation mod√©r√©e d'alcool, alimentation riche en fruits et l√©gumes).

        **Impact :**
        - L‚Äôinfection √† *H. pylori* est r√©pandue dans les pays en voie de d√©veloppement, y compris au S√©n√©gal.
        - Des strat√©gies de sant√© publique adapt√©es sont essentielles pour r√©duire le fardeau du cancer gastrique dans ces r√©gions.
        """
    )


    # Pr√©sentation de l'√©quipe
    st.markdown("## üë• √âquipe de Recherche")
    cols = st.columns(3)

    for i, member in enumerate(TEAM_MEMBERS):
        with cols[i]:
            if os.path.exists(member["photo"]):
                st.image(member["photo"], width=100)
            st.markdown(f"**{member['name']}**  \n*{member['role']}*")
            st.markdown(f"[üìß Email]({member['email']})")
            st.markdown(f"[üîó LinkedIn]({member['linkedin']})")

def contact():
    st.title("üì© Contact")
    st.markdown(
        """
        #### Coordonn√©es
        
        üåç Localisation : Bambey, BP 13, S√©n√©gal
        
        üìû T√©l√©phone : +221 77 808 09 42
        
        üì© E-mail : ahmed.sefdine@uadb.edu.sn
        """
    )
    with st.form("contact_form"):
        name = st.text_input("Nom complet")
        email = st.text_input("Email")
        message = st.text_area("Message")
        if st.form_submit_button("Envoyer"):
            st.success("‚úÖ Message envoy√© avec succ√®s !")

# ----------------------------------------------------------
# Navigation Principale (Onglets en haut)
# ----------------------------------------------------------
PAGES = {
    "üè† Accueil": accueil,
    "üìä Analyse": analyse_descriptive,
    "ü§ñ Pr√©diction": modelisation,
    "üìö √Ä Propos": a_propos,
    "üì© Contact": contact
}

def main():
    # Ajout d'un style CSS pour aligner les onglets √† droite
    st.markdown(
        """
        <style>
        /* Ajuster l'alignement des onglets vers la droite */
        .stTabs [data-baseweb="tab"] {
            justify-content: flex-end;
        }
        </style>
        """,
        unsafe_allow_html=True
    )

    tabs = st.tabs(list(PAGES.keys()))
    for tab, (page_name, page_func) in zip(tabs, PAGES.items()):
        with tab:
            page_func()

if __name__ == "__main__":
    main()
